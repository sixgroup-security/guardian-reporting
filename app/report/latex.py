# This file is part of Guardian.
#
# Guardian is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Guardian is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Guardian. If not, see <https://www.gnu.org/licenses/>.

import base64
import os
import re
import enum
import logging
import pypandoc
from io import BytesIO
from urllib.parse import urlparse
from enum import Enum, IntEnum
from core.config import Settings
from .util import ReportCreatorBase
from schema import ReportGenerationInfo, SessionLocal
from schema.user import UserReport, User
from schema.util import SeverityType
from schema.reporting.file import FileReport
from schema.reporting.report_template import ReportTemplateFileVersion
from schema.reporting.report_section_management.vulnerability import (
    VulnerabilityReport, Vulnerability, VulnerabilityStatus
)
from PIL import Image, ImageOps, ImageDraw
from typing import Callable, Dict, List

__author__ = "Lukas Reiter"
__copyright__ = "Copyright (C) 2024 Lukas Reiter"
__license__ = "GPLv3"

DEFAULT_AVATAR = "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"
logger = logging.getLogger(__name__)


class FileName(Enum):
    report = "report.tex"
    package = "guardian.sty"
    title_page = "01_title_page.tex"
    prefix_sections = "02_prefix_sections.tex"
    report_history = "02_1_report_history.tex"
    authors = "02_2_authors.tex"
    executive_summary = "03_executive-summary.tex"
    postfix_sections = "04_postfix_sections.tex"
    report_scope = "04_1_report_scope.tex"


class LatexSeverityColor(IntEnum):
    critical_color = enum.auto()
    high_color = enum.auto()
    medium_color = enum.auto()
    low_color = enum.auto()
    # info_color = (0, 0, 255)


SeverityColorMapping = {
    LatexSeverityColor.critical_color.name: SeverityType.critical.name,
    LatexSeverityColor.high_color.name: SeverityType.high.name,
    LatexSeverityColor.medium_color.name: SeverityType.medium.name,
    LatexSeverityColor.low_color.name: SeverityType.low.name,
    # LatexSeverityColor.info_color.name: SeverityType.info.name
}


class ReportCreator(ReportCreatorBase):
    """
    This class is responsible for creating the Latex source code for a full report.
    """
    def __init__(
            self,
            info: ReportGenerationInfo,
            images_dir: str,
            **kwargs
    ):
        super().__init__(info=info, **kwargs)
        self.images_dir = images_dir
        self.images_full_path = os.path.join(self.work_dir, images_dir)
        self.report_sections = self.project.report.sections
        self.post_placeholder_pattern = re.compile(r"\\\{\\\{\.([\w(\\_)]+)(?::([\w\\\.:\(\)\s=,;]+))?\\\}\\\}")
        self.image_pattern = re.compile(r'!\[(?P<caption>.*?)\]\((?P<path>.+?)\)')
        # We need to convert the severity distribution to the correct format for the barchart.
        # {"critical_color": [("Section 1", 1), ("Section 2", 2)], "high_color": ...}
        self._severity_section_distribution = {item.name: [] for item in LatexSeverityColor}
        self._severities = []
        for color in LatexSeverityColor:
            severity = SeverityColorMapping[color.name]
            self._severities.append(severity.capitalize())
            result = [(section.name, section.severity_distribution_dict[severity]) for section in self.report_sections]
            self._severity_section_distribution[color.name] = result
        self._re_latex_commands = re.compile(r"\\(\w+)[\s\*]*(\[.*?\])?\s*\{.*?\}", re.IGNORECASE)

    @property
    def tex_file(self):
        """
        Returns the tex file's full path.
        """
        return os.path.join(self.work_abspath, self.settings.latex_template_file)

    def _save_avatar(self, user: UserReport | User):
        """
        This method fits the avatar image.
        """
        if not user:
            return
        avatar = user.avatar if user.avatar else base64.b64decode(DEFAULT_AVATAR)
        # Create a BytesIO object from the byte stream
        byte_io = BytesIO(avatar)
        # Open image file
        img = Image.open(byte_io)
        # Resize image to a square
        img = ImageOps.fit(img, (300, 300))
        # Create circular mask
        mask = Image.new('L', (300, 300), 0)
        draw = ImageDraw.Draw(mask)
        draw.ellipse((0, 0, 300, 300), fill=255)
        # Apply mask to image
        img.putalpha(mask)
        # Save circular thumbnail image
        img.save(os.path.join(self.images_full_path, f"{user.id}.png"))

    def convert_markdown_images(self, report_text):
        """
        Converts Markdown image URLs from API format to local file include format.

        :param report_text: str, the report text containing Markdown image URLs.
        :return: str, the final text with Markdown image URLs converted.
        """
        def image_replacement(match):
            caption = match.group("caption")
            url = urlparse(match.group("path"))
            file_path = os.path.join(self.images_dir, f"{os.path.basename(url.path)}.png")
            try:
                if url.query:
                    parameters = [tuple(item.split("=")) for item in url.query.split("&")]
                    width = list(filter(lambda x: x[0] == "w", parameters))
                    try:
                        width = float(width[0][1])
                        width = width if width <= 1 else 1
                        width = width if width > 0 else 0.1
                    except:
                        width = None
                else:
                    width = None
            except Exception as ex:
                self._logger.exception(ex)
                width = None
            return f'![{caption}]({file_path})' if width is None else f'![{caption}]({file_path}){{width={width * 100}%}}'
        return self.image_pattern.sub(image_replacement, report_text)

    def default_placeholder_func(
            self,
            placeholder_name: str,
            params: Dict[str, str],
            matched_string: str,
            final_name: str | None
    ):
        """
        Default placeholder function that replaces placeholders with the final value.
        :param placeholder_name: str, the placeholder name.
        :param params: dict, dictionary containing placeholder parameters.
        :param matched_string: str, the matched placeholder string.
        :param final_name: str, the final value for the placeholder.
        :return:
        """
        result = self.replace_placeholders_only_func(
            placeholder_name=placeholder_name,
            params=params,
            matched_string=matched_string,
            final_name=final_name
        )
        if placeholder_name == "barchart":
            result = self.get_bar_chart(params)
        elif placeholder_name == "vulnerability_overview":
            result = self.get_vulnerability_overview()
        elif placeholder_name == "vulnerability_details":
            result = self.get_vulnerability_details()
        elif placeholder_name == "reportscope":
            logger.debug("Process placeholder: reportscope")
            # Create the report scope Latex file
            label = params.get("label")
            caption = params.get("caption")
            column_widths = params.get("columnwidths", "")
            if self._get_report_scope(
                widths_cm=column_widths.split(","),
                label=label,
                caption=caption,
            ):
                result = f"""
\\input{{{FileName.report_scope.value}}}"""
        return result

    def pre_report_placeholder_func(
            self,
            placeholder_name: str,
            params: Dict[str, str],
            matched_string: str,
            final_name: str | None
    ):
        """
        Placeholder function to process the pre-report text that replaces placeholders with the final value.
        :param placeholder_name: str, the placeholder name.
        :param params: dict, dictionary containing placeholder parameters.
        :param matched_string: str, the matched placeholder string.
        :param final_name: str, the final value for the placeholder.
        :return:
        """
        result = ""
        if placeholder_name == "is_final_report":
            self._logger.debug("Process placeholder: is_final_report")
            result = params.get("true", "NOT FOUND") if self.latest_version_info.is_final \
                else params.get("false", "NOT FOUND")
        elif placeholder_name == "report_history":
            logger.debug("Process placeholder: report_history")
            result = f"""
\\input{{{FileName.report_history.value}}}"""
        elif placeholder_name == "team_members":
            logger.debug("Process placeholder: team_members")
            result = f"""
\\input{{{FileName.authors.value}}}"""
        elif placeholder_name == "table_of_contents":
            logger.debug("Process placeholder: table_of_contents")
            result = """{
\\setcounter{tocdepth}{\\mytocdepth}
\\tableofcontents
}"""
        return result

    def _get_figure(self, content: str, caption: str | None, label: str | None) -> str:
        """
        Encapsulates the given content into a figure environment.
        """
        label_command = f"\\label{{{label}}}{os.linesep}" if label else ""
        caption_command = f"\\caption{{{caption}}}{os.linesep}" if caption else ""
        return f"""
\\begin{{figure}}[h!]
\\centering
{content}
{caption_command}
{label_command}
\\end{{figure}}
"""

    def get_bar_chart(self, parameters: Dict[str, str]) -> str:
        """
        This method returns the barchart.
        """
        sections = [self.test_latex_injection(section.name) for section in self.project.report.sections]
        label = parameters.get('label')
        caption = parameters.get('caption')
        width = parameters.get('width', '0.9\\textwidth')
        height = parameters.get('height', '4cm')
        bar_width = parameters.get('barwidth', '10pt')
        # The lesser components we have, the higher the enlargelimits number can become (the higher the number, the
        # closer the individual components are together). Three components .2, two components: .7.
        large_limits = parameters.get('enlargelimits', '0.4')
        font_size = parameters.get('fontsize', '\\tiny')
        legend_item_distance = parameters.get('legenditemdistance', '2.5em')
        category_box_width = parameters.get('categoryboxwidth', '2.5cm')
        result = f"""
\\begin{{tikzpicture}}
    \\begin{{axis}}[
        ybar,
        ymin=0,
        y axis line style={{opacity=0}},
        ymajorgrids=true,
        width={width},
        height={height},
        bar width={bar_width},
        enlargelimits={large_limits},
        nodes near coords style={{font={font_size},/pgf/number format/assume math mode}},
        every node near coord/.append style={{font={font_size}}},
        label style={{font={font_size}}},
        tick label style={{font={font_size},/pgf/number format/assume math mode}},
        x axis line style={{-}},
        y axis line style={{-}},
        axis y line*=left,
        axis x line*=bottom,
        tick style={{draw=none}},
        nodes near coords,
        nodes near coords align={{vertical}},
        symbolic x coords={{{",".join(sections)}}},
        xtick = data,
        enlarge y limits={{value=0.2,upper}},
        x tick label style={{text width={category_box_width},align=center}},
        legend image code/.code={{\\draw [#1, ultra thin] (0cm,-0.08cm) rectangle (0.2cm,0.12cm); }},
        legend style={{at={{(0.5, -0.3)}},font={font_size},anchor=north,legend columns=-1,draw=none,/tikz/every even column/.append style={{column sep={legend_item_distance}}}}}
    ]
"""
        for severity in self._severity_section_distribution:
            # (Application 1, 0) (Infrastructure, 0)
            values = " ".join([
                f"({section}, {value})" for section, value in self._severity_section_distribution[severity]
            ])
            result += f"\\addplot[fill={severity.replace('_', '')},draw=none] coordinates {{{values}}};{os.linesep}"
        result += f"""\\legend{{{", ".join(self._severities)}}}
    \\end{{axis}}
\\end{{tikzpicture}}
"""
        return self._get_figure(result, caption, label) if caption or label else result

    def get_vulnerability(
            self,
            vulnerability: VulnerabilityReport
    ) -> List[str]:
        """
        Creates the tex file for the given vulnerability.
        """
        result = []
        if vulnerability.status == VulnerabilityStatus.resolved:
            title_prefix = "[Resolved] "
        elif vulnerability.status == VulnerabilityStatus.review:
            title_prefix = "[Review] "
        else:
            title_prefix = ""
        # Save files
        for file in vulnerability.files:
            file.save_to_file(self.images_full_path)
        # Create vulnerability report
        vulnerability_name = self.get_tex(
            f"{title_prefix}{vulnerability.name}",
            pre_placeholder_fn=self.replace_placeholders_only_func
        )

        cwe_weakness = self.test_latex_injection(vulnerability.cwe_weakness_str or "")
        cwe_weakness_id = self.test_latex_injection(vulnerability.cwe_weakness_id or "")
        cwe_weakness_link = (
            self.get_tex(f"[{cwe_weakness}]({self.settings.cvss_definitions_url}/{cwe_weakness_id})")
            if cwe_weakness_id else "-"
        )
        # Add the vulnerabilities header
        result.append("\\{severity}header{{{name}}}{{{cwe}}}{{{label}}}{{ID-{vulnid:03d}}}".format(
            severity=vulnerability.severity.name,
            name=vulnerability_name,
            cwe=cwe_weakness_link,
            label=vulnerability.reference_str,
            vulnid=vulnerability.vulnerability_id)
        )
        result.append("\\subsubsection*{{General Description}}")
        result.append(self.get_tex(
            vulnerability.description,
            pre_placeholder_fn=self.replace_placeholders_only_func,
            has_images=True
        ))
        result.append("")
        result.append("\\subsubsection*{{Observation / Proof-of-Concept}}")
        result.append(self.get_tex(
            vulnerability.observation,
            pre_placeholder_fn=self.replace_placeholders_only_func,
            has_images=True
        ))
        result.append("")
        result.append("\\subsubsection*{{Recommendations}}")
        result.append(self.get_tex(
            vulnerability.measure_recommendation,
            pre_placeholder_fn=self.replace_placeholders_only_func,
            has_images=True
        ))
        result.append("")
        if vulnerability.references:
            result.append("\\subsubsection*{{References}}")
            result.append(self.get_tex(
                vulnerability.references or "",
                pre_placeholder_fn=self.replace_placeholders_only_func
            ))
        result.append("")
        result.append("\\subsubsection*{{Vulnerability Scoring System Information (CVSS v{version})}}".format(
            version=self.settings.cvss_version
        ))
        if vulnerability.rating_comment:
            result.append(self.get_tex(
                vulnerability.rating_comment or "",
                pre_placeholder_fn=self.replace_placeholders_only_func
            ))
            result.append("")
            result.append("")
        if vulnerability.cvss_score and vulnerability.cvss_score > 0 and vulnerability.cvss_vector:
            cvss_vector = self.test_latex_injection(vulnerability.cvss_vector)
            cvss_link = self.get_tex(f"[{cvss_vector}]({self.settings.cvss_base_url}#{cvss_vector})")
            result.append(
                "\\cvssheader{{{score}}}{{{severity}}}{{{cvss_calculator_url}}}".format(
                    score=vulnerability.cvss_score,
                    severity=vulnerability.severity_str,
                    cvss_calculator_url=cvss_link)
            )
        else:
            result.append("\\cvssheader{{{score}}}{{{severity}}}{{{cvss_calculator_url}}}".format(
                score="-",
                severity=vulnerability.severity_str,
                cvss_calculator_url="-")
            )
        result.append("\\newpage")
        return result

    def get_vulnerability_overview(self) -> str:
        """
        Implements logic for placeholder {{.vulnerability_overview}}.
        """
        result = []
        for section in self.report_sections:
            if len(self.report_sections) > 1:
                result.append("\\subsubsection*{{{section}}}".format(
                    section=self.get_tex(section.name))
                )
            if len(section.vulnerabilities) == 0:
                result.append("No issues were identified.")
            for vulnerability in section.vulnerabilities:
                if not vulnerability.visible:
                    continue
                result.append(f"""\\nameref{{header:{vulnerability.reference_str}}}""")
                result.append("")
        if result:
            result.append("\\newpage")
        return os.linesep.join(result)

    def get_vulnerability_details(self):
        """
        Implements logic for placeholder {{.vulnerability_details}}
        """
        result = []
        for section in self.report_sections:
            previous_severity = None
            result.append("\\subsection{{{section}}}".format(section=self.get_tex(section.name)))
            result.append("")
            if section.description:
                result.append(self.get_tex(section.description, pre_placeholder_fn=self.replace_placeholders_only_func))
                result.append("")
            if len(section.vulnerabilities) == 0:
                result.append("No issues were identified.")
            for vulnerability in section.vulnerabilities:
                # Create subsection if necessary
                if previous_severity != vulnerability.severity:
                    previous_severity = vulnerability.severity
                    result.append("\\subsubsection*{{Severity: {severity}}}".format(
                        severity=self.get_tex(vulnerability.severity_str))
                    )
                # Create vulnerability description file
                result += self.get_vulnerability(vulnerability)
        return os.linesep.join(result)

    def write_file(self, file: FileName | None, content: str, mode: str = "w") -> str:
        """
        This method writes the content to the given file.
        """
        file_name = os.path.join(self.work_dir, str(file.value))
        if not file:
            return content
        with open(file_name, mode) as f:
            f.write(content)
        return content

    def save_images(self, images: List[FileReport]):
        """
        Saves the images to the images directory.
        """
        for image in images:
            image.save_to_file(os.path.join(self.work_dir, self.images_full_path))

    def test_latex_injection(self, markdown: str) -> str:
        """
        This method checks for unauthorized LaTeX commands in the given Markdown text.
        """
        def latex_injection(match):
            result = match.group(0)
            latex_command = match.group(1)
            if latex_command.lower() not in self.settings.latex_command_whitelist:
                version = f" and version '{self.latest_version_info.version}'" if self.latest_version_info else ""
                self._logger.warning(
                    f"Usage of unauthorized LaTeX command '{result}' in report '{self.report.id}'{version}"
                )
                result = ""
            return result
        return self._re_latex_commands.sub(latex_injection, markdown)

    def get_tex(
            self,
            markdown: str | None,
            pre_placeholder_fn: Callable[[str, Dict[str, str], str, str | None], str | None] | None = None,
            post_placeholder_fn: Callable[[str, Dict[str, str], str, str | None], str | None] | None = None,
            has_images: bool = False
    ) -> str:
        """
        This method converts the given Markdown text to Latex.

        :param markdown: str, the Markdown text to convert.
        :param pre_placeholder_fn: function, a function that processes placeholders before the conversion.
        :param post_placeholder_fn: function, a function that processes placeholders after the conversion.
        :param has_images: bool, whether the Markdown text contains images.
        """
        result = self.test_latex_injection(markdown)
        # We need to normalize figures from URLs to local file paths.
        result = self.convert_markdown_images(result) if has_images else markdown
        # We need to replace placeholders with the final values.
        result = self.replace_placeholders(
            report_text=result,
            placeholder_values=self.placeholders,
            placeholder_pattern=self.pre_placeholder_pattern,
            placeholder_fn=pre_placeholder_fn
        ) if pre_placeholder_fn else result
        # We need to convert the Markdown to Latex.
        result = pypandoc.convert_text(
            source=result,
            to="tex",
            format="markdown",
            extra_args=self.settings.pandoc_arguments,
            encoding="utf-8",
            verify_format=True,
            sandbox=True,
            # cworkdir=self.work_dir
        ).strip()
        # We perform post-processing on the placeholders.
        result = self.replace_placeholders(
            report_text=result,
            placeholder_values=self.placeholders,
            placeholder_pattern=self.post_placeholder_pattern,
            placeholder_fn=post_placeholder_fn
        ) if post_placeholder_fn else result
        # We perform final post-processing (e.g., replace \href by \slink or 1 by 1^{st}).
        return self.post_processing_func(result)

    def _get_report(self) -> str:
        """
        This method creates the report.
        """
        command = lambda file: f"\\input{{{file.value}}}{os.linesep}"
        result = command(FileName.title_page)
        result += """\\addtocontents{toc}{\\protect\\setcounter{tocdepth}{-1}}
\\setcounter{secnumdepth}{0}
"""
        result += command(FileName.prefix_sections)
        result += """
\\setcounter{secnumdepth}{4}

\\addtocontents{toc}{\\protect\\setcounter{tocdepth}{1}}
\\begin{multicols}{2}
"""
        result += command(FileName.executive_summary)
        result += """\\end{multicols}
\\addtocontents{toc}{\\protect\\setcounter{tocdepth}{\\mytocdepth}}

\\newpage
"""
        result += command(FileName.postfix_sections)
        return self.write_file(FileName.report, result)

    def _get_package(self) -> str:
        """
        This method creates/returns the variables file.
        """
        command = lambda command, value: f"\\newcommand{{\\{command}}}{{{value}}}{os.linesep}"
        result = ""
        for key, value in self.placeholders.items():
            if isinstance(value, str):
                result += command(key.replace("_", ""), value)
        return self.write_file(FileName.package, result, mode="a")

    def _get_report_history(self) -> str:
        """
        This method returns the report history.
        """
        result = """
\\begin{table}[h!]
    \\begin{tabular*}{\\textwidth}{l l l l l@{\\extracolsep{\\fill}}}\\hline
    \\textbf{Version} & \\textbf{State} & \\textbf{Name} & \\textbf{Date} & \\textbf{Description} \\\\\\hline
""".strip()
        for version in self.report.versions:
            created_at = f"{version.report_date:%d.%m.%Y}"
            version_status = version.status.name.upper()
            user_name = self.test_latex_injection(version.username)
            comment = self.test_latex_injection(version.comment)
            result += f"""
{version.version} & {version_status} & {user_name} & {created_at} & {comment} \\\\\\hline"""
        result += """
    \\end{tabular*}
\\end{table}
""".strip()
        return self.write_file(FileName.report_history, result)

    def _get_report_scope(
            self,
            widths_cm: List[str],
            caption: str | None = None,
            label: str = None
    ) -> str | None:
        """
        This method returns the report scope.
        """
        if len(widths_cm or []) != 6 or not any([str(item).isnumeric() for item in widths_cm]):
            logger.debug(f"Skip creating report scope table due to invalid widths_cm parameter: {widths_cm}")
            return None
        if label_str := self.test_latex_injection(label or ""):
            label_str = f"\\label{{{label_str}}}"
        if caption_str := self.test_latex_injection(caption or ""):
            caption_str = f"\\caption{{{caption_str}{label_str}}}"
        column_widths = " ".join([f"p{{{item}cm}}" for item in widths_cm])

        # Create rows
        ref = 1
        rows = []
        for scope in self.report.scopes:
            asset = scope.asset or ""
            asset = self.get_tex(f"`{asset}`")
            zone = self.test_latex_injection(scope.zone or "")
            view = scope.view.name.capitalize() if scope.view else "-"
            description = self.get_tex(scope.description or "")
            if scope.strong_authentication is None:
                mfa = "-"
            elif scope.strong_authentication:
                mfa = "Yes"
            else:
                mfa = "No"
            rows.append(f"{ref} & {view} & {asset} & {zone} & {mfa} & {description}\\\\\\hline")
            ref += 1

        result = f"""
        \\begin{{longtable}}[h!]{{{column_widths}}}
        {caption_str}\\hline
        \\textbf{{Ref.}} & \\textbf{{View}} & \\textbf{{Target}} & \\textbf{{Zone}} & \\textbf{{Strong Auth.}} & \\textbf{{Description}} \\\\\\hline
        {''.join(rows)}
        \\end{{longtable}}
        """
        return self.write_file(FileName.report_scope, result)

    def _get_author_row(self, user: UserReport | User, roles: List[str]) -> str:
        """
        This method returns a row for the authors table.
        """
        image_path = os.path.join(self.images_dir, f"{user.id}.png")
        role_items = " \\item ".join([self.test_latex_injection(item) for item in roles]).strip()
        full_name = self.test_latex_injection(user.full_name)
        user_email = self.test_latex_injection(user.email)
        return f"""
\\includegraphics[width=30mm]{{{image_path}}} & {full_name} & &
\\begin{{minipage}}[t]{{0.4\\textwidth}}
  \\begin{{itemize}}
      \\item \\setlength{{\\itemindent}}{{-0.3pt}}\\setlength{{\\itemsep}}{{-1ex}}{role_items}
  \\end{{itemize}}
\\end{{minipage}} &
\\begin{{minipage}}[t]{{0.4\\textwidth}}
  \\begin{{itemize}}\\setlength{{\\itemindent}}{{-0.3pt}}\\setlength{{\\itemsep}}{{-1ex}}
      \\item \\slink{{mailto:{user_email}}}{{{user_email}}}
  \\end{{itemize}}
\\end{{minipage}} \\\\
"""

    def _get_authors(self) -> str:
        """
        This method returns the authors.
        """

        self._save_avatar(self.project.lead_tester)
        result = """
\\begin{table}[h!]
    \\begin{tabularx}{\\textwidth}{m{3cm} m{1.8cm} m{.5cm} m{4cm} m{4cm}}\\hline
        \\multicolumn{2}{c}{\\textbf{Person}} & & \\textbf{Responsibility} & \\textbf{Contact Details} \\\\\\hline
& & & & \\\\[-1ex]
"""
        if self.project.lead_tester:
            result += self._get_author_row(self.project.lead_tester, ["Lead Penetration Tester"])
        for tester in self.project.testers:
            self._save_avatar(tester)
            result += self._get_author_row(tester, ["Penetration Tester"])
        result += """
& & & & \\\\[-1ex]\\hline
    \\end{tabularx}
\\end{table}
"""
        return self.write_file(FileName.authors, result)

    def _get_title_page(self) -> str:
        """
        This method returns the title page.
        """
        result = """
\\begin{titlepage}

\\vspace*{\\fill}
{\\huge{\\reportstatus Report}}\\\\[0.1em]
{\\huge\\textbf{\\color{criticalcolor}{{.project_name}}}}
\\vskip 2.5em

{\\large\\textbf{Project}}\\\\
\\makebox[4cm][l]{Project}         \\makebox{{{.project_name}}}\\\\
\\makebox[4cm][l]{CCPT-ID}         \\makebox{{{.project_id}}}\\\\
\\makebox[4cm][l]{Customer}        \\makebox{{{.customer_name}}}\\\\
\\makebox[4cm][l]{Timeline}        \\makebox{{{.test_period}}}\\\\
\\makebox[4cm][l]{Assessor/s}      \\makebox{{{.assessors}}}\\\\
\\vskip 1.5em

{\\large\\textbf{Document}}\\\\
\\makebox[4cm][l]{Name}            \\makebox{{{.pdf_file_name}}}\\\\
\\makebox[4cm][l]{Version}         \\makebox{{{.report_version}}}\\\\
\\makebox[4cm][l]{Classification}  \\makebox{{{.classification}}}\\\\
\\makebox[4cm][l]{Pages}           \\makebox{\\pageref{LastPage}}\\\\
\\makebox[4cm][l]{Date}            \\makebox{{{.delivery_date}}}\\\\
\\makebox[4cm][l]{Provider}        \\makebox{{{.provider_name}}}\\\\
\\makebox[4cm][l]{Author/s}        \\makebox{{{.assessors}}}\\\\


\\vspace*{\\fill}

\\end{titlepage}

\\pagenumbering{arabic}
"""
        result = self.get_tex(result, pre_placeholder_fn=self.replace_placeholders_only_with_latex_escape_func)
        return self.write_file(FileName.title_page, result)

    def _get_executive_summary(self) -> str:
        """
        This method returns the executive summary.
        """
        result = self.get_tex(
            self.report.executive_summary,
            pre_placeholder_fn=self.default_placeholder_func,
            has_images=True
        )
        return self.write_file(FileName.executive_summary, result)

    def _get_report_prefix(self) -> str:
        """
        This method returns the report prefix.
        """
        result = self.get_tex(
            self.report.prefix_section_text,
            pre_placeholder_fn=self.default_placeholder_func,
            post_placeholder_fn=self.pre_report_placeholder_func,
            has_images=True
        )
        return self.write_file(FileName.prefix_sections, result)

    def _get_report_postfix(self) -> str:
        """
        This method returns the report postfix.
        """
        result = self.get_tex(
            self.report.postfix_section_text,
            pre_placeholder_fn=self.default_placeholder_func,
            has_images=True
        )
        return self.write_file(FileName.postfix_sections, result)

    def create(self):
        """
        Creates the Latex sources based on the given data.
        """
        self._preparation()
        self._create()

    def _preparation(self):
        """
        Checks the prerequisites for creating the Latex files.
        """
        # Check placeholders for invalid LaTeX commands
        for key, value in self.placeholders.items():
            self._placeholders[key] = self.test_latex_injection(value)
        # Save images
        self.save_images(self.project.report.files)
        self.save_images(self.project.report.report_template.files)

    def _create(self):
        """
        Creates the Latex sources based on the given data.
        """
        # Create the report package
        self._get_package()
        # Create the report Latex file that is imported by the main Latex file.
        self._get_report()
        # Create the title page.
        self._get_title_page()
        # Create the report history Latex file.
        self._get_report_history()
        # Create the authors Latex file.
        self._get_authors()
        # Create the report prefix Latex file.
        self._get_report_prefix()
        # Create the executive summary Latex file.
        self._get_executive_summary()
        # Create the report postfix Latex file.
        self._get_report_postfix()

    def get_zip(self) -> bytes:
        """
        Returns the created file structure as a ZIP file.
        :return:
        """
        return self.create_zip(self.work_dir)

    @staticmethod
    def check(settings: Settings):
        """
        Checks prerequisites for creating Latex files.
        """
        # Check if Excel template file exist
        for version in ReportTemplateFileVersion:
            latex_template_directory = settings.get_latex_template_directory(version)
            latex_template_file = settings.get_latex_template_file(version)
            if not os.path.isdir(latex_template_directory):
                raise FileNotFoundError(f"Latex template directory '{latex_template_directory}' not found.")
            if not os.path.isfile(latex_template_file):
                raise FileNotFoundError(f"Latex template file '{latex_template_file}' not found.")


class VulnerabilityCreator(ReportCreator):
    """
    This class is responsible for creating the Latex source code for a vulnerability.
    """

    def __init__(
            self,
            vulnerability: Vulnerability,
            **kwargs
    ):
        super().__init__(**kwargs)
        self.vulnerability = VulnerabilityReport.from_orm(vulnerability)

    def _get_report(self) -> str:
        """
        This method creates the report.
        """
        result = self.get_vulnerability(self.vulnerability)
        result = os.linesep.join(result)
        return self.write_file(FileName.report, result)

    def _create(self):
        """
        Creates the Latex sources based on the given data.
        """

        # Create the report package
        self._get_package()
        # Create the report Latex file that is imported by the main Latex file.
        self._get_report()
